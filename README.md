# Truebit Roadmap

The current repo will house the design documents, Truebit's roadmap, the links to useful resources and other material related to or useful for Truebit.

## Table Of Contents

- [Overview](#overview)
  - [Roles](#roles)
  - [Components](#components)
- [Incentive Layer](#overview)
- [Announcements](#incentive-layer)
- [Imposed Limitations](#imposed-limitations)
- [Quick Summary](#quick-summary)
- [Proof of Concept](#proof-of-concept)
- [Community](#community)
- [Project Links](#project-links)
- [Resources](#resources)
- [Contribution Guidelines](#contribution-guidelines)

## Overview

The short version is Truebit is an incentivized scalability solution for distributed trustless networks.<br/>
The protocol is enforced by playing an interactive "game". The interactive game involes certain roles and pieces of software that comproise the truebit protocol.<br/>
Before we see what "playing the game" means lets first look at some definitions:<br/>
First we'll definge the roles:<br/>

### Roles
* Taskgiver: is the miner posting a task that requires verification on whether or not the task was carried out correctly by the Solver.<br/>
* Solver: is the miners chosen to run the task for a reward.<br/>
* Verifier(s): are the miners that check the task and it's computation posted to the blockchain by the solver.<br/>
* Challenger(s): are the verifiers that see a mismatch between the hashes of the Truebit machine posted on the blockchain by the solver and their own hashes of the internal state of the truebit machine generated by the truebit offline interpreter.<br/>
* Referees(s): are the miners that will oversee the time-outs imposed on the verification game while the solver is solving the task and verifiers are verifying it.<br/>
* Judges(s): are the miners<br/>

### Components
* Off-chain Interpreter: is the off-chain truebit [WASM](https://github.com/WebAssembly/) machine that runs a WASM object file and generates merkle proofs of the internal state of the machine.<br/>
* On-chain Interpreter: is the WASM interpreter written in Solidity. Same functionality as off-chain interpreter but all computations done on the blockchain.<br/>
* Truebit Contracts: there are separate contracts for TaskGiver, Solver, and Verifier. Each contract is in charge of the balances for each user. A user can submit a deposit to one of these smart contracts and then use the contract methods to participate in the TrueBit protocol.<br/>
* Dispute Resolution Layer: At the heart of TrueBit’s protocol lies an interactive “verification game” which decides whether or not a contested computational task was performed correctly. The verification game proceeds through a series of rounds, where each round recursively checks a smaller and smaller subset of the computation. A trusted network, in our case the Ethereum platform , merely enforces the rules of the game and therefore does not bear the bulk of the verification burden.<br/>
* Incentive Layer: The economics behind TrueBit are similar to cloud services. Alice pays Amazon for computing power. TrueBit allows Alice, the task giver, to pay anyone on the network like Bob. In order to ensure Bob, the solver, actually solves the task correctly. Bob allows for his solution to be challenged by a Verifier. Since the probability of actually finding an error is low, TrueBit's incentive layer offers bug bounties and provides the expectation that there will be bugs to find. TrueBit randomly forces a Solver to submit an incorrect solution to be checked by verifiers. If a verifier finds that Bob submitted an incorrect solution they will be compensated while Bob will be punished.<br/>

## Incentive Layer

### Preprocessing steps
* Initialize Jackpot contract with a large deposit from a philanthropist.
* Initialize TrueBit contract with a universal tax rate T.
* Solvers an Verifiers that wish to participate in the coming rounds commit ETH as deposit to the Truebit contract. They will only be able to participate in Tasks where their deposit is sufficient, as deemed by Task Giver.
* Solvers generate private random bits r and commit their hash to the Truebit smart contract.

### Main Algorithm
1. a Task Giver creates a Task on the TrueBit contract, by providing the following:
  * task: a computational task (or more accurately, its hash).
  * timeOut: a time value (probably in terms of blocks) to allow for performing of computation and waiting for a challenge.
  * reward: ETH which will be held in escrow by the contract.
    * reward >= (cash equivalent of task difficulty d based on the timeOut) + (total tax of T * d).
    * This has to cover:
      1. cost of computation done by Solver,
      2. payment for Verifier, which goes into Jackpot for now as a Tax, and gets paid out to lucky one who finds unforced-error at future data and amortizes all past costs.
      3. work done by referees and judges.
  * minDeposit: the minimum deposit needed to participate as a Solver or Verifier.
    * Some tasks have high economic dependencies downstream-effects. Therefore, Task Giver wants to increase skin-in-the-game of Solver and Verifier and give them incentive to not lie.

2. Solvers who have the requisite minDeposit AND random bits can bid to TrueBit smart contract to take on the task, before timeOut elapses.
3. Referees, i.e. the miners, select one Solver by lottery.
IF no Solver takes on the task in the allotted time, THEN the task request is canceled and Task Gives receives a full refund.
4. The selected Solver privately computes task.
  * IF timeOut expires before a solution, THEN the Solver forfeits his deposit to the jackpot and the protocol terminates.
  * OTHERWISE, Solver commits both a "correct" and "incorrect" solution to the TrueBit contract (more accurately, the hash of a solution).

5. The next block gets mined. Depending on the block hash and their previously committed-to random bit r, the Solver knows whether a forced error is in effect. Therefore, the Solver pings the Truebit contract and designates one of their submitted hashes as the solution.

6. Before timeOut has elapsed: verifiers who have posted minDeposit can challenge (the hash of) solution . They do this by committing the hash of an even integer to the Truebit contract to commit to a challenge.

7. After timeOut elapses, interested Verifiers broadcasts to the blockchain this hashed number in the clear to reveal their action.
  1. IF no Verifier challenges solution, THEN:
    * Solver reveals r. IF there was no forced error, THEN Solver reveals solution and received the task reward ($). (This is the most common play-out of the game).
    * Solver reveals r. IF there was a forced error, THEN protocol has failed since no one challenged. (This is the most uncommon play-out of the game)
  2. ELSE a Verifier challenges solution, THEN:
    * Solver reveals their random string r to the Truebit contract. Referees check it against their commitment from the preprocessing step.
    *  IF hash of concat of r and block hash is small (as determined by the forced error rate), THEN a forced error is in effect. Note: in these cases, the Solver does not receive a reward, but instead a Jackpot payout much greater than reward. This is because we assume they would have challenged their own solution.
        1.  Solver reveals their secondary (aka "correct") solution in the clear.
        2. IF no Verifier challenges Solver's secondary solution before timeOut, THEN Verifier wins a fraction of the jackpot J, scaled for task difficulty.
          *  Note: If there are multiple Challengers with same solution hash, they split the Jackpot reward in exponentially-decreasing chunks.
          * Note: If there are multiple distinct challenges, then they play the verification game serially. Challenges are ordered FIFO for implementation simplicity.
        3. ELSE a Verifier challenges Solver's secondary solution, THEN they play the verification game.
          * IF Solver loses, THEN the Verifier penalties, Verifier rewards, Solver penalties, and refunds to the Task Giver are the same as next step. (what happens to first verifier who challenged the forced error?)
          * ELSE IF Solver wins (i.e. their secondary solution was correct), the original Verifier gets their jackpot reward.
    * ELSE, the error was not forced.
        1. Solver reveals solution in the clear, and the Solver and Verifier play a verification game.
          * In case of challenges from multiple verifiers, verification games play in serial, until a Challenger defeats Solver or the Solver defeats all Challengers.
        2. IF solver wins, the Verifier forfeits half of their deposit to the Jackpot and the other half to the Solver.
            * This is not a large reward, compared to winning a jackpot payout for an unforced error.
        3. ELSE IF Challenger wins, the Solver pays back the Task Giver reward and tax, pays at most half of his deposit to Verifier (exponentially-decreasing given how many challenges there were), and forfeits remaining funds to the Jackpot. If the Task Giver still doesn’t know the correct solution in this case. Need to re-issue Task.

### Notes on Economics
The jackpot payout for discovering a forced error must cover amortized payment for all verification tasks. (i.e. have a worthwhile Expected Value).
I.e.: (Jackpot payout) >= (fair compensation for one task) * 1 / (forced error rate).
The jackpot for each task scales proportionally with the task’s complexity (to equally incentivize work on both easy and hard tasks).
The max jackpot payout for forced error is 1/3 total jackpot size. (To prevent the Jackpot from getting depleted).

### Values
T: the universal tax rate, established when Truebit contract is deployed.
d: task difficulty as determined by timeOut provided by Task Giver.


## Announcements

## Imposed Limitations
* External Calls: external calls are a source of non-deterministic execution. Truebit needs the task to be deterministic so that the solver and verifier can both run the exact same internal states for the same task. For an example of how external calls yield different internal states, think of the pid of the child process returned by the `fork` system call or a random generator function. It could be argued that the non-determinism introduced by the external calls can be "local" and does not affect the final state(or the part of it that counts). The rise of formal specification  might have something to say about this issue but for the proof of concept implementation of Truebit, will not try to tackle this issue.<br/>
* Floating-Point: WASM's specification allows some nondeterminism for floating-point arithmetic. The solver originally runs the task using any WASM build toolchain. Needless to say we cannot gurantee the toolchains used will behave the same when it comes to the non-determinism in floating-point arithmetic.<br/>

## Quick Summary

## Proof Of Concept

## Community
* [Slack](https://truebit.slack.com/messages/C5G74SV6V/)<br/>
* [Reddit](https://www.youtube.com/redirect?redir_token=cWQgq0FMKvmnIJFWyAc8msETA0V8MTUwNTk5ODI3MkAxNTA1OTExODcy&event=desc&q=https%3A%2F%2Fwww.reddit.com%2Fr%2Ftruebit%2F)<br/>

  [![epiccenter-truebit](img/epiccenter.png)](https://www.youtube.com/watch?v=QY0OUTaIWIc&t=977s)

## Project Links
* [Truebit Website](https://truebit.io)<br/>
* [Ocaml Off-chain Interpreter](https://github.com/TrueBitFoundation/ocaml-offchain)<br/>
* [On-chain Interpreter](https://github.com/TrueBitFoundation/webasm-solidity)<br/>
* [Incentive Layer Contracts](https://github.com/TrueBitFoundation/truebit-contracts)<br/>
* [Scrypt-Interactive](https://github.com/TrueBitFoundation/scrypt-interactive)<br/>
* [Python Off-chain Interpreter](https://github.com/TrueBitFoundation/python-offchain) - DEPRECATED<br/>

## Resources
* [Truebit Whitepaper](https://people.cs.uchicago.edu/~teutsch/papers/truebit.pdf)

## Contribution Guidelines
